demo()
install.packages(c("slidify", "ggplot2", "devtools"))
require(devtools)
install.packages("rtools")
require(devtools)
install_github("slidify", "ramnathv")
install.packages("kernsmooth")
install.packages("KernSmooth")
install.packages("KernSmooth")
library(KernSmooth)
if (x > 3) {}
x = 8
if (x > 3) { y <- 10 } else { y <- 2 }
x <- c("a", "b", "c", "d")
for(i in 1:4) {print(x[i])}
for(i in seq_along(x)) {print(x[i])}
for(letter in x) {print(letter)}
for(i in 1:4) print(x[i])
add2 <- function(x, y) {
x + y
}
above <- function(x, n) {
use <- x > n
x[use]
}
x = int[1:20]
x = [1:20]
x <- [1:20]
above <- function(x, n = 10) {
use <- x > n
x[use]
}
x <- c(1:20)
above(x)
above(x, 2)
above <- function(x, n = 15) {
use <- x > n
x[use]
}
above(x)
columnmean <- function(y) {
nc <- ncol(y)
means <- numeric(nc)
for(i in 1:nc) {
means[i] <- means(y[, i])
}
}
columnmean(inv(x))
inverse(x)
columnmean <- function(y, removeNA = TRUE) {
nc <- ncol(y)
means <- numeric(nc)
for(i in 1:nc) {
means[i] <- means(y[, i])
}
}
na.rn
na.rm
y = [1;2;3;4]
y = c(1, 2, 3, 4, cols = 1)
y
y = matrix(1, 2, 4, na.rm, 5, 6)
y = matrix(nrow = 2, ncol = 3)
y
y[1]
y[1,2]
y[1:]
y[1, ]
y[ , 1]
y[ , 1] <- c(3, 4)
y
m <- 1:10
dim(m) <- c(2, 5)
m
m[2, 4] <- na.rn
m[2, 4] <- NA
m
columnmean(m)
columnmean <- function(y, removeNA = TRUE) {
nc <- ncol(y)
means <- numeric(nc)
for(i in 1:nc) {
means[i] <- mean(y[, i], na.rm = removeNA)
}
means
}
columnmean(m)
columnmean(m, FALSE)
setwd("E:/Coursework/Coursera/Johns_Hopkins__R_Programming")
#comment
mean
args(paste)
args(cat)
paste("a", "b", sep = ":")
paste("a", "b", se = ":")
search()
cls
clr
clr()
cls()
# Example: Maximizing a Normal Likelihood
make.NegLogLik <- function(data, fixed = c(FALSE, FALSE)) {
params <- fixed
function(p) {
params[!fixed] <- p
mu <- params[1]
sigma <- params[2]
a <- -0.5 * length(data) * log(2 * pi * sigma^2)
b <- -0.5 * sum((data - mu)^2) / (sigma^2)
-(a + b)
}
}
set.seed(1); normals <- rnorm(100, 1, 2)
nLL <- make.NegLogLike(normals)
nLL
# Example: Maximizing a Normal Likelihood
make.NegLogLike <- function(data, fixed = c(FALSE, FALSE)) {
params <- fixed
function(p) {
params[!fixed] <- p
mu <- params[1]
sigma <- params[2]
a <- -0.5 * length(data) * log(2 * pi * sigma^2)
b <- -0.5 * sum((data - mu)^2) / (sigma^2)
-(a + b)
}
}
nLL <- make.NegLogLike(normals)
nLL
ls(environment(nLL))
optim(c(mu = 0, sigma = 1), nLL)$par
nLL <- make.NegLogLike(normals, c(FALSE, 2))
optimize(nLL, c(-1, 3))$minimum
nLL <- make.NegLogLike(normals, c(1, FALSE))
optimize(nLL, c(1e-6, 10))$minimum
nLL <- make.NegLogLike(normals, c(1, FALSE))
x <- seq(1.7, 1.9. len = 100)
x <- seq(1.7, 1.9, len = 100)
y = sapply(x, nLL)
plot(x, exp(-(y - min(y))), type = "1")
plot(x, exp(-(y - min(y))), type = "l")
nLL <- make.NegLogLike(normals, c(FALSE, 2))
x <- seq(0.5, 1.5, len = 100)
y <- sapply(x, nLL)
plot(x, exp(-(y - min))), type = "l")
plot(x, exp(-(y - min(y)))), type = "l")
plot(x, exp(-(y - min(y))), type = "l")
x <- as.Date("1970-01-01")
x
unclass(x)
unclass(as.Date("1970-01-02"))
x <- Sys.time()
x
p <- as.POSIXlt(x)
p
names(unclass(p))
p$sec
x <- 1:10
x > 5
if(x > 5) {x <- 0}
3L
L
class(L)
unclass(L)
unclass(3L)
unclass(3)
names(unclass(3L))
names(unclass(3))
solve(m)
mat = 1:16
dim(mat)
dim(mat) <- c(4,4)
mat
test = 1:25
dim(test) <- c(5)
dim(test) <- c(5, 5)
solve(test)
test
m
mat
solve(mat)
unclass(mat)
names(unclass(mat))
mat = rbind(c(1, 2), c(3, 4))
mat
solve(c)
solve(mat)
type(mat)
setwd("E:/Coursework/Coursera/Johns_Hopkins__R_Programming/ProgrammingAssignment2")
list(set = set, get = get, setinverse = setinvser, getinverse = getinverse)
source('E:/Coursework/Coursera/Johns_Hopkins__R_Programming/ProgrammingAssignment2/cachematrix.R')
makeCacheMatrix(mat)
source('E:/Coursework/Coursera/Johns_Hopkins__R_Programming/ProgrammingAssignment2/cachematrix.R')
makeCacheMatrix(mat)
cacheSolve(makeCacheMatrix(mat))
cacheSolve(makeCacheMatrix(mat))
cacheMatrix <- makeCacheMatrix(mat)
cacheMatrix
cacheSolve(cacheMatrix)
str(mat)
t(mat)
str(t(mat))
mat <- t(mat)
cacheMatrix <- makeCacheMatrix(t(mat))
cacheMatrix
cacheMatrix$get()
cacheSolve(cacheMatrix)
mat <- matrix(1:9, ncol = 3)
mat
str(mat)
cacheMatrix <- makeCacheMatrix(mat)
cacheMatrix$get()
cacheSolve(cacheMatrix)
t(mat)
cacheMatrix <- makeCacheMatrix(t(mat))
cacheSolve(cacheMatrix)
source('E:/Coursework/Coursera/Johns_Hopkins__R_Programming/ProgrammingAssignment2/cachematrix.R')
cacheSolve(cacheMatrix)
cacheMatrix$get()
solve(matrix(1:9, ncol=3))
m = rbind(c(1, -1/4), c(-1/4, 1))
c
m
mat(m)
str(m)
solve(m)
cacheMatrix <- makeCacheMatrix(m)
cacheSolve(cacheMatrix)
cacheMatrix$getinverse
cacheMatrix$getinverse()
